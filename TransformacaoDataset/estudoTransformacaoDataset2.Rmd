---
title: "estudoTransformacaoDataset2"
author: "Rodrigo"
date: "December 19, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#Carregando dataset
```{r}
dataset = read.csv("~/Desktop/datasets_UCI/monks-2/original.csv", header = T)

x_data = dataset[,-ncol(dataset)]
y_data = dataset[,ncol(dataset)]

```


#Convertendo os labels para numerico
```{r}
y_data = as.numeric(y_data)
```


#Escolhendo a classe minotiraria
Quero escolher a menor classe cuja proporcal(vs. all) seja maior que 5%
```{r}
minority_class = 1
class_count = Inf
for (i in unique(y_data)){
  if(as.numeric(table(y_data)[as.character(i)])/length(y_data) > 0.05){
    
    if(as.numeric(table(y_data)[as.character(i)]) < class_count){
      minority_class = i
    }
  }
}

#classe minoritaria 
print(minority_class)
#porcentagem
print(as.numeric(table(y_data)[as.character(minority_class)])/length(y_data))
```


#Binarizando o dataset
```{r}
y_data = replace(y_data, y_data == minority_class, -1)
y_data = replace(y_data, y_data != -1, -2)

y_data = replace(y_data, y_data == -1, 1)
y_data = replace(y_data, y_data == -2, 0)

```


```{r}
#Essa funcao recebe como parametros os preditores(x_data) e a classe(y_data) de um dataset. Recebe como parametro a porcentagem exigida de classe minoritária para um novo dataset. É feito apenas undersampling, nenhum dado é replicado. O undersampling sempre favorece a retirada da classe majoritária, assim preservando o maximo possível a classe minoritária.
imba_sample = function(x_data, y_data, minority_percent){
  
  
  if(length(which(y_data == 1)) < 10){
    warning("A classe minoritária nao tem observacoes suficientes.")
    return()
  }
  
  #Devemos ter no mínimo 10 observacoes da classe minoritária(regra do estudo)
  while(length(which(y_data == 1)) >= 10){
    
    #Calculamos o necessário de obs. da classe majoritária para que a classe minoritária represente
    # o valor de 'minority_percent' no conjunto total
    needed_majoritary_abs_count = ceiling(length(which(y_data == 1))*0.95/minority_percent)

    if(length(which(y_data == 0)) >= needed_majoritary_abs_count){
      
      #Indices do novo dataset desbalanceado
      new_indexs = c(which(y_data == 1), which(y_data == 0)[1:needed_majoritary_abs_count])
      
      new_dataset = cbind(x_data[new_indexs,], y_data[new_indexs])
      names(new_dataset)[ncol(new_dataset)] = 'y_data'
      return(new_dataset)
    }else{
      #Caso não tenhamos o numero necessário de obs. da classe majoritária, nós retiramos uma obs. da minoritária
      # e tentamos novamente.
      
      #seleciona um indice da classe minoritaria para remover
      remove_index = which(y_data == 1)[1]
      
      #removendo
      x_data = x_data[-remove_index,]
      y_data = y_data[-remove_index]
    }
  }
  
  warning("A classe minoritária nao tem observacoes suficientes.")
  return()
  
}
```


#Gerando Datasets
```{r}
ds_0.05 = imba_sample(x_data, y_data, 0.05)
length(which(ds_0.05[,'y_data'] == 1))/dim(ds_0.05)[1]

ds_0.03 = imba_sample(x_data, y_data, 0.03)
length(which(ds_0.03[,'y_data'] == 1))/dim(ds_0.03)[1]

ds_0.01 = imba_sample(x_data, y_data, 0.01)
length(which(ds_0.01[,'y_data'] == 1))/dim(ds_0.01)[1]

ds_0.001 = imba_sample(x_data, y_data, 0.001)
length(which(ds_0.001[,'y_data'] == 1))/dim(ds_0.001)[1]


```
